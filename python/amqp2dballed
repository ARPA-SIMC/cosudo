#!/usr/bin/env python
# GPL. (C) 2014 Paolo Patruno.

# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
# 

import os
import logging,logging.handlers

#os.environ['DJANGO_SETTINGS_MODULE'] = 'rmap.settings'
#import django
#django.setup()

from rmap import daemon
import pika, subprocess
import traceback
import rmap.settings

user=rmap.settings.amqpuser
password=rmap.settings.amqppassword
host="localhost"

#add option for topic and dsn
class  mydaemon(daemon.Daemon):

    def optionparser(self):
        op = super(mydaemon, self).optionparser()
	op.add_option("-d", "--datalevel",dest="datalevel", help="sample or report: define the istance to run: select topic, dns,logfile, errorfile and lockfile (default %default)", default=None)
	op.add_option("-s", "--stationtype",dest="stationtype", help="fixed or mobile: define the istance to run: select topic, dns,logfile, errorfile and lockfile (default %default)", default=None)
	#op.add_option("-t", "--topic",dest="topic", help="topic root to subscribe on mqtt broker (default %default)", default="rmap")
	#op.add_option("-d", "--dsn",dest="dsn", help="topic root to subscribe on mqtt broker (default %default)", default=rmap.settings.dsnrmap)
        return op 	  				 



amqp2dballed = mydaemon(
        stdin="/dev/null",
        stdout=rmap.settings.logfileamqp2dballed,
        stderr=rmap.settings.errfileamqp2dballed,
        pidfile=rmap.settings.lockfileamqp2dballed,
        user=rmap.settings.useramqp2dballed,
        group=rmap.settings.groupamqp2dballed
)

def callback(ch, method, properties, body):
    logging.info("Received message")


    try:
        amqp2dballed.procs = [subprocess.Popen(["dbadb","import","-f","--dsn="+ch.dsn], stdin=subprocess.PIPE)]
        outstdout,outstderr=amqp2dballed.procs[0].communicate(input=body)

        if (outstdout): logging.debug(outstdout)
        if (outstderr): logging.error(outstderr)
            
        status=amqp2dballed.procs[0].wait()
        if status != 0:
            logging.error("There were some errors executing dbadb import error: %s" % status)
            logging.debug("skip message: ")
            logging.debug(body)
            logging.debug("---------------------")

    except Exception as exception:
        logging.error("There were some errors executing dbadb import")
        logging.error('Exception occured: ' + str(exception))
        logging.error(traceback.format_exc())
        raise

    else:
                          
        logging.info("Done")
        ch.basic_ack(delivery_tag = method.delivery_tag)


    # TODO how we can pass procs to daemon ? 

def main(self):

    # configure the logger
    formatter=logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s",datefmt="%Y-%m-%d %H:%M:%S")
    handler = logging.handlers.RotatingFileHandler(self.options.stdout, maxBytes=5000000, backupCount=10)
    handler.setFormatter(formatter)
    
    # Add the log message handler to the root logger
    logging.getLogger().addHandler(handler)
    logging.getLogger().setLevel(logging.INFO)

    logging.info('Starting up amqp2dballed')
    
    dsndict={"sample":{},"report":{}}
    dsndict["sample"]["fixed"]=rmap.settings.dsnsample_fixed
    dsndict["sample"]["mobile"]=rmap.settings.dsnsample_mobile
    dsndict["report"]["fixed"]=rmap.settings.dsnreport_fixed
    dsndict["report"]["mobile"]=rmap.settings.dsnreport_mobile

    if (not self.options.datalevel is None):
        if not (self.options.datalevel in dsndict.keys()):
            logging.error('Invalid dsn')
            sys.stdout.write("Invalid dsn\n")
            return False

    if (not self.options.stationtype is None):
        if not (self.options.stationtype in dsndict[self.options.datalevel].keys()):
            logging.error('Invalid dsn')
            sys.stdout.write("Invalid dsn\n")
            return False

    if (self.options.stationtype is None != self.options.datalevel is None ):
            logging.error('Invalid: only one of datalevel and stationtype options are missed ')
            sys.stdout.write("Invalid: only one of datalevel and stationtype options are missed\n")
            return False

    if (self.options.stationtype is None and self.options.datalevel is None ):
        queue="dballe"
        dsn=rmap.settings.dsn
    else:        
        queue=self.options.datalevel+"_"+self.options.stationtype
        dsn   = dsndict[self.options.datalevel][self.options.stationtype]

    logging.info('Queue: %s' % queue)
    logging.info('DSN: %s'% dsn)
    
    credentials=pika.PlainCredentials(user, password)

    connection = pika.BlockingConnection(pika.ConnectionParameters(
        host=host,credentials=credentials))
    channel = connection.channel()

    #save in channel for callback
    channel.dsn=dsn

    #channel.queue_declare(queue=queue)
    
    channel.basic_consume(callback,
            queue=queue,
            no_ack=False)

    try:
        logging.info('Waiting for messages. To exit press CTRL+C')
        channel.start_consuming()

    # log and retry on exception 
    except Exception as exception:
        logging.error('Exception occured: ' + str(exception))
        logging.error(traceback.format_exc())
        logging.error('Start_consuming failed')
        status=False    
    # terminate on keyboard interrupt
    except KeyboardInterrupt:
        sys.stdout.write("keyboard interrupt\n")
        logging.info("keyboard interrupt\n")
        status=True    
    # terminate without error
    else:
        # no exception was raised
        logging.info('Start_consuming terminated')
        status=True
    finally:
        # we have to terminate together with other exceptions                          
        logging.info('Subprocess finished')

    return status

                          

if __name__ == '__main__':

    import sys, os
    amqp2dballed.cwd=os.getcwd()

    if amqp2dballed.service():

        sys.stdout.write("Daemon started with pid %d\n" % os.getpid())
        sys.stdout.write("Daemon stdout output\n")
        sys.stderr.write("Daemon stderr output\n")

        status=main(amqp2dballed)  # (this code was run as script)

        for proc in amqp2dballed.procs:
            proc.wait()

        sys.exit(status)
