#!/usr/bin/python3
# GPL. (C) 2020 Paolo Patruno.

# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
#

import signal
import os
import re
import json
from datetime import datetime
import dballe
import paho.mqtt.client as mqtt
import pika
import logging,traceback
import time,queue
import threading

os.environ['DJANGO_SETTINGS_MODULE'] = 'rmap.settings'
import django
django.setup()


from rmap import daemon
import rmap.settings

user=rmap.settings.amqpuser
password=rmap.settings.amqppassword
#host="localhost"
host="test.rmap.cc"

TOPIC_RE = re.compile((
    r'^.*/'
    r'(?P<ident>[^/]+)/'
    r'(?P<lon>[0-9-]+),'
    r'(?P<lat>[0-9-]+)/'
    r'(?P<rep>[^/]+)/'
    r'(?P<pind>[0-9]+|-),'
    r'(?P<p1>[0-9]+|-),'
    r'(?P<p2>[0-9]+|-)/'
    r'(?P<lt1>[0-9]+|-),'
    r'(?P<lv1>[0-9]+|-),'
    r'(?P<lt2>[0-9]+|-),'
    r'(?P<lv2>[0-9]+|-)/'
    r'(?P<var>B[0-9]{5})$'
))


class amqpProducer(threading.Thread):
    def __init__(self,host,exchange,send_queue=None,logging=logging):
        """Create a new instance of the producer class, passing in the AMQP
        URL used to connect to RabbitMQ.

        :param str amqp_url: The AMQP url to connect with

        """

        threading.Thread.__init__(self)

        self._connection = None
        self._channel = None
        self._stopping = False
        self._host = host
        self._exchange=exchange
        self._logging=logging
        self._running = False
        self._send_queue=send_queue

        self._deliveries = None
        self._acked = None
        self._nacked = None
        self._message_number = None
        self._terminate_event = threading.Event()

    def terminate(self):
        self._terminate_event.set()

    def have_to_terminate(self):
        return self._terminate_event.is_set()
        
    def publish(self,body):
        """This method publish message to RabbitMQ exhange
        """
        self._logging.info('Publish to %s', self._exchange)

        properties=pika.BasicProperties(
            user_id= user,
            delivery_mode = 2, # persistent
        )
        routing_key=user
        
        try:
            self._channel.basic_publish(exchange=self._exchange,
                                  routing_key=routing_key,
                                  body=body,
                                  properties=properties)
            self._message_number += 1
            self._deliveries.append(self._message_number)
            
            self._logging.debug('Message published # %i',self._message_number)
            return True
        except pika.exceptions.UnroutableError:
            self._logging.error('Message could not be confirmed')
            return False

        
        
    def connect(self):
        """This method connects to RabbitMQ, returning the connection handle.
        When the connection is established, the on_connection_open method
        will be invoked by pika.

        :rtype: pika.SelectConnection

        """
        self._logging.info('Connecting to %s', self._host)
        self._logging.info('User %s; Password %s', user,password)

        credentials=pika.PlainCredentials(user, password)
        self._connection= pika.SelectConnection(pika.ConnectionParameters(host=self._host,credentials=credentials),

                                                on_open_callback=self.on_connection_open,
                                                on_open_error_callback=self.on_connection_open_error,
                                                on_close_callback=self.on_connection_closed)


    def on_connection_open(self, unused_connection):
        """This method is called by pika once the connection to RabbitMQ has
        been established. It passes the handle to the connection object in
        case we need it, but in this case, we'll just mark it unused.

        :type unused_connection: pika.SelectConnection

        """
        self._logging.info('Connection opened')
        self.open_channel()

    def on_connection_open_error(self, _unused_connection, err):
        """This method is called by pika if the connection to RabbitMQ
        can't be established.
        :param pika.SelectConnection _unused_connection: The connection
        :param Exception err: The error
        """

        self._logging.error('Connection open failed, reopening in 5 seconds: %s', err)
        self._connection.ioloop.call_later(5, self._connection.ioloop.stop)


    def on_connection_closed(self, _unused_connection, reason):
        """This method is invoked by pika when the connection to RabbitMQ is
        closed unexpectedly. Since it is unexpected, we will reconnect to
        RabbitMQ if it disconnects.

        :param pika.connection.Connection connection: The closed connection obj
        :param int reply_code: The server provided reply_code if given
        :param str reply_text: The server provided reply_text if given

        """
        self._channel = None
        if self._stopping:
            self._connection.ioloop.stop()
        else:
            self._logging.warning('Connection closed, reopening in 5 seconds: %s',
                                  reason)
            self._connection.ioloop.call_later(5, self._connection.ioloop.stop)


    def open_channel(self):
        """Open a new channel with RabbitMQ by issuing the Channel.Open RPC
        command. When RabbitMQ responds that the channel is open, the
        on_channel_open callback will be invoked by pika.

        """
        self._logging.info('Creating a new channel')
        self._connection.channel(on_open_callback=self.on_channel_open)

    def on_channel_open(self, channel):
        """This method is invoked by pika when the channel has been opened.
        The channel object is passed in so we can make use of it.

        Since the channel is now open, we'll declare the exchange to use.

        :param pika.channel.Channel channel: The channel object

        """
        self._logging.info('Channel opened')
        self._channel = channel
        self.add_on_channel_close_callback()

        # Turn on delivery confirmations
        self._channel.confirm_delivery(ack_nack_callback=self.on_delivery_confirmation)

    def on_delivery_confirmation(self,method_frame):

        confirmation_type = method_frame.method.NAME.split('.')[1].lower()
        self._logging.info('Received %s for delivery tag: %i', confirmation_type,
                    method_frame.method.delivery_tag)
        if confirmation_type == 'ack':
            self._acked += 1
        elif confirmation_type == 'nack':
            self._nacked += 1
        self._deliveries.remove(method_frame.method.delivery_tag)
        self._logging.info(
            'Published %i messages, %i have yet to be confirmed, '
            '%i were acked and %i were nacked', self._message_number,
            len(self._deliveries), self._acked, self._nacked)
    
    def add_on_channel_close_callback(self):
        """This method tells pika to call the on_channel_closed method if
        RabbitMQ unexpectedly closes the channel.

        """
        self._logging.info('Adding channel close callback')
        self._channel.add_on_close_callback(self.on_channel_closed)

    def on_channel_closed(self, channel, reason):
        """Invoked by pika when RabbitMQ unexpectedly closes the channel.
        Channels are usually closed if you attempt to do something that
        violates the protocol, such as re-declare an exchange or queue with
        different parameters. In this case, we'll close the connection
        to shutdown the object.

        :param pika.channel.Channel: The closed channel
        :param int reply_code: The numeric reason the channel was closed
        :param str reply_text: The text reason the channel was closed

        """
        self._logging.warning('Channel %i was closed: (%s)',
                              channel, reason)
        self._channel = None
        if not self._stopping:
            self._connection.close()


    def close_channel(self):
        """Call to close the channel with RabbitMQ cleanly by issuing the
        Channel.Close RPC command.

        """
        self._logging.info('Closing the channel')
        self._channel.close()

    def get_messages(self):


        def send_message(message):
            self._logging.debug("elaborate %s bytes" % len(message))

            try:
                self.publish(message)
                
            except Exception as exception:
                self._logging.error("There were some errors sendin message to AMQP")
                self._logging.debug("skip message: ")
                self._logging.debug(message)
                self._logging.debug("---------------------")
                self._logging.error('Exception occured: ' + str(exception))
                self._logging.error(traceback.format_exc())

                # requeue message
                self._send_queue.put_nowait(message)                    
                
            finally:
                self._send_queue.task_done()                    


        totalbody=b""
        while not self._send_queue.empty():
            # get a message
            totalbody+=(self._send_queue.get())

            if (len(totalbody) > 1000000):
                send_message(totalbody)
                totalbody=b""

        if len(totalbody) > 0:
            send_message(totalbody)

        if(self.have_to_terminate()):
            self.stop()
        else:
            self._connection.ioloop.call_later(5, self.get_messages)

        
    def begin(self):
        """Run the example producer by connecting to RabbitMQ and then
        starting the IOLoop to block and allow the SelectConnection to operate.

        """
        self._deliveries = []
        self._acked = 0
        self._nacked = 0
        self._message_number = 0
        
        self.connect()
        self._connection.ioloop.call_later(10, self.get_messages)
        self._connection.ioloop.start()

    def run(self):
        while not self._stopping:
            try:
                self.begin()
            except KeyboardInterrupt:
                self.stop()
                if (self._connection is not None and
                        not self._connection.is_closed):
                    # Finish closing
                    self._connection.ioloop.start()
        self._logging.info('Terminated')

    def stop(self):
        """Cleanly shutdown the connection to RabbitMQ by stopping the producer
        with RabbitMQ. When RabbitMQ confirms the cancellation, on_cancelok
        will be invoked by pika, which will then closing the channel and
        connection. The IOLoop is started again because this method is invoked
        when CTRL-C is pressed raising a KeyboardInterrupt exception. This
        exception stops the IOLoop which needs to be running for pika to
        communicate with RabbitMQ. All of the commands issued prior to starting
        the IOLoop will be buffered but not processed.

        """
        self._logging.info('Stopping')
        self._stopping = True
        self.close_connection()
        self._logging.info('Stopped')

    def close_connection(self):
        """This method closes the connection to RabbitMQ."""
        self._logging.info('Closing connection')
        self._connection.close()



class MyMQTTClass(mqtt.Client):

    def parse_topic(self,topic):
        match = TOPIC_RE.match(topic)
        if match is None:
            return None
        else:
            g = match.groupdict()
            return {
                "ident": None if g["ident"] == "-" else g["ident"],
                "lon": int(g["lon"]),
                "lat": int(g["lat"]),
                "rep_memo": g["rep"],
                "level": (
                    None if g["lt1"] == "-" else int(g["lt1"]),
                    None if g["lv1"] == "-" else int(g["lv1"]),
                    None if g["lt2"] == "-" else int(g["lt2"]),
                    None if g["lv2"] == "-" else int(g["lv2"]),
                ),
                "trange": (
                    None if g["pind"] == "-" else int(g["pind"]),
                    None if g["p1"] == "-" else int(g["p1"]),
                    None if g["p2"] == "-" else int(g["p2"]),
                ),
                "var": g["var"],
            }

    def parse_payload(self,payload):
        return json.loads(payload.decode("utf-8"))

    def parse_message(self,topic, payload):
        t = self.parse_topic(topic)
        if t is None:
            return None

        m = self.parse_payload(payload)
        msg = t.copy()
        msg["value"] = m["v"]
        if all([
                t["level"] != (None, None, None, None),
                t["trange"] != (None, None, None),
        ]):
            if "d" in m:
                msg["datetime"] = datetime.strptime(m["d"], "%Y-%m-%dT%H:%M:%S")
            else:
                msg["datetime"] = datetime.now()
        else:
            msg["datetime"] = None
    
        if "a" in m:
            msg["attributes"] = m["a"]
        else:
            msg["attributes"] = {}
            
        return msg

    def on_log(self,client, userdata, level, buf):
        if userdata["logging"]:
            userdata["logging"].debug(buf)

    def on_connect(self,client, userdata, flags, rc):
        for topic in userdata["topics"]:
            client.subscribe(topic)

    def on_message(self,client, userdata, message):

        if userdata["logging"]:
            logging=userdata["logging"]

        if userdata["send_queue"]:
            send_queue=userdata["send_queue"]
            
        logging.info('Message: topic '+str(message.topic) +" payload "+str(message.payload))
        
        try:
            m = self.parse_message(message.topic, message.payload)
            if m is None:
                    return
            msg = dballe.Message("generic")
            if m["ident"] is not None:
                msg.set_named("ident", dballe.var("B01011", m["ident"]))

            msg.set_named("longitude", dballe.var("B06001", m["lon"]))
            msg.set_named("latitude", dballe.var("B05001", m["lat"]))
            msg.set_named("rep_memo", dballe.var("B01194", m["rep_memo"]))

            if m["datetime"] is not None:
                msg.set_named("year", dballe.var("B04001", m["datetime"].year))
                msg.set_named("month", dballe.var("B04002", m["datetime"].month))
                msg.set_named("day", dballe.var("B04003", m["datetime"].day))
                msg.set_named("hour", dballe.var("B04004", m["datetime"].hour))
                msg.set_named("minute", dballe.var("B04005", m["datetime"].minute))
                msg.set_named("second", dballe.var("B04006", m["datetime"].second))

            var = dballe.var(m["var"], m["value"])

            for b, v in m["attributes"].items():
                var.seta(dballe.var(b, v))

            msg.set(m["level"], m["trange"], var)

            exporter = dballe.Exporter(encoding="BUFR")
            totalbody=exporter.to_binary(msg)
            #sys.stdout.buffer.write(exporter.to_binary(msg))
            #sys.stdout.flush()

            send_queue.put_nowait(totalbody)

        except Exception:
            import traceback
            traceback.print_exc()


#add option for topic and dsn
class  mydaemon(daemon.Daemon):

    def optionparser(self):
        op = super(mydaemon, self).optionparser()
        op.add_option("-d", "--datalevel",dest="datalevel", help="sample or report: define the istance to run: select topic, dns,logfile, errorfile and lockfile (default %default)", default="sample")
        op.add_option("-s", "--stationtype",dest="stationtype", help="fixed or mobile: define the istance to run: select topic, dns,logfile, errorfile and lockfile (default %default)", default="fixed")
        #op.add_option("-t", "--topic",dest="topic", help="topic root to subscribe on mqtt broker (default %default)", default="rmap")
        #op.add_option("-d", "--dsn",dest="dsn", help="topic root to subscribe on mqtt broker (default %default)", default=rmap.settings.dsnrmap)
        return op 	  				 

mqtt2amqpd = mydaemon(
        stdin="/dev/null",
        stdout=rmap.settings.logfilemqtt2amqpd,
        stderr=rmap.settings.errfilemqtt2amqpd,
        pidfile=rmap.settings.lockfilemqtt2amqpd,
        user=rmap.settings.usermqtt2amqpd,
        group=rmap.settings.groupmqtt2amqpd
)

# catch signal to terminate the process
class GracefulKiller:
    kill_now = False
    def __init__(self):
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)

    def exit_gracefully(self,signum, frame):
        self.kill_now = True

    def keyboard_interrupt(self):
        self.kill_now = True

    def terminate(self):
        self.kill_now = True

def main(self):

    import os,sys,time
    import logging.handlers
    import subprocess
    import traceback

    #arm the signal handler
    killer = GracefulKiller()

    # configure the logger
    formatter=logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s",datefmt="%Y-%m-%d %H:%M:%S")
    handler = logging.handlers.RotatingFileHandler(self.options.stdout, maxBytes=5000000, backupCount=10)
    handler.setFormatter(formatter)
    
    # Add the log message handler to the root logger
    logging.getLogger().addHandler(handler)
    logging.getLogger().setLevel(logging.DEBUG)

    logging.info('Starting up mqtt2amqpd')

    dsndict={"sample":{},"report":{}}
    dsndict["sample"]["fixed"]=rmap.settings.dsnsample_fixed
    dsndict["sample"]["mobile"]=rmap.settings.dsnsample_mobile
    dsndict["report"]["fixed"]=rmap.settings.dsnreport_fixed
    dsndict["report"]["mobile"]=rmap.settings.dsnreport_mobile

    
    if not (self.options.datalevel in list(dsndict.keys())):
        logging.error('Invalid dsn')
        sys.stdout.write("Invalid dsn\n")
        return False

    if not (self.options.stationtype in list(dsndict[self.options.datalevel].keys())):
        logging.error('Invalid dsn')
        sys.stdout.write("Invalid dsn\n")
        return False

    topicdict={"sample":{},"report":{}}
    topicdict["sample"]["fixed"]  = "{}/+/+/{}/#".format(rmap.settings.topicsample,"fixed")
    topicdict["sample"]["mobile"] = "{}/+/+/{}/#".format(rmap.settings.topicsample,"mobile")
    topicdict["report"]["fixed"]  = "{}/+/+/{}/#".format(rmap.settings.topicreport,"fixed")
    topicdict["report"]["mobile"] = "{}/+/+/{}/#".format(rmap.settings.topicreport,"mobile")


    if not (self.options.datalevel in list(topicdict.keys())):
        logging.error('Invalid topic')
        sys.stdout.write("Invalid topic\n")
        return False

    if not (self.options.stationtype in list(topicdict[self.options.datalevel].keys())):
        logging.error('Invalid topic')
        sys.stdout.write("Invalid topic\n")
        return False

    dsn   = dsndict[self.options.datalevel][self.options.stationtype]
    logging.info('DSN: %s'% dsn)
    topic = topicdict[self.options.datalevel][self.options.stationtype]
    logging.info('Topic: %s'% topic)
    
    exchange=self.options.datalevel+"_"+self.options.stationtype


    send_queue = queue.Queue(maxsize=1000000)

    amqp=amqpProducer(host,exchange,send_queue,logging)
    amqp.start()

    # If you want to use a specific client id, use
    # mqttc = MyMQTTClass("client-id")
    # but note that the client id must be unique on the broker. Leaving the client
    # id parameter empty will generate a random id for you.

    mqttclient = MyMQTTClass(userdata={
        "topics": [topic],
        "logging": logging,
        "send_queue": send_queue,
    })
    
    mqttclient.connect(host=host)


    # infinite loop
    while True:
        try:
            mqttclient.loop()
        except Exception as exception:
            logging.error('Exception occured: ' + str(exception))
            logging.error(traceback.format_exc())
            killer.terminate()
            
        # terminate on keyboard interrupt
        except KeyboardInterrupt:
            sys.stdout.write("keyboard interrupt\n")
            logging.info("keyboard interrupt\n")
            killer.keyboard_interrupt()

        # terminate without error
        # no exception was raised
        #logging.info('work finished')
            
        # check if we have to terminate together with other exceptions
        if killer.kill_now:

            mqttclient.disconnect()
            logging.debug("MQTT connection closed")
            
            amqp.terminate()
            amqp.join()
            logging.debug("AMQP connection closed")

            logging.info("killed by signal\n")
            logging.info('Subprocess finished')
            return False
    
            

if __name__ == '__main__':

    import sys, os
    
    mqtt2amqpd.cwd=os.getcwd()

    if mqtt2amqpd.service():

        sys.stdout.write("Daemon started with pid %d\n" % os.getpid())

        main(mqtt2amqpd)  # (this code was run as script)
            
        for proc in mqtt2amqpd.procs:
            proc.wait()

        sys.stdout.write("Daemon stoppped\n")
        sys.exit(0)
