#!/usr/bin/python3
# GPL. (C) 2020 Paolo Patruno.

# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or 
# (at your option) any later version. 
# 
# This program is distributed in the hope that it will be useful, 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
# GNU General Public License for more details. 
# 
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
#

import signal
import os
import re
import json
from datetime import datetime
import dballe
import paho.mqtt.client as mqtt
import pika
import logging

os.environ['DJANGO_SETTINGS_MODULE'] = 'rmap.settings'
import django
django.setup()


from rmap import daemon
import rmap.settings

user=rmap.settings.amqpuser
password=rmap.settings.amqppassword
#host="localhost"
host="test.rmap.cc"

TOPIC_RE = re.compile((
    r'^.*/'
    r'(?P<ident>[^/]+)/'
    r'(?P<lon>[0-9-]+),'
    r'(?P<lat>[0-9-]+)/'
    r'(?P<rep>[^/]+)/'
    r'(?P<pind>[0-9]+|-),'
    r'(?P<p1>[0-9]+|-),'
    r'(?P<p2>[0-9]+|-)/'
    r'(?P<lt1>[0-9]+|-),'
    r'(?P<lv1>[0-9]+|-),'
    r'(?P<lt2>[0-9]+|-),'
    r'(?P<lv2>[0-9]+|-)/'
    r'(?P<var>B[0-9]{5})$'
))


class MyMQTTClass(mqtt.Client):

    def parse_topic(self,topic):
        match = TOPIC_RE.match(topic)
        if match is None:
            return None
        else:
            g = match.groupdict()
            return {
                "ident": None if g["ident"] == "-" else g["ident"],
                "lon": int(g["lon"]),
                "lat": int(g["lat"]),
                "rep_memo": g["rep"],
                "level": (
                    None if g["lt1"] == "-" else int(g["lt1"]),
                    None if g["lv1"] == "-" else int(g["lv1"]),
                    None if g["lt2"] == "-" else int(g["lt2"]),
                    None if g["lv2"] == "-" else int(g["lv2"]),
                ),
                "trange": (
                    None if g["pind"] == "-" else int(g["pind"]),
                    None if g["p1"] == "-" else int(g["p1"]),
                    None if g["p2"] == "-" else int(g["p2"]),
                ),
                "var": g["var"],
            }

    def parse_payload(self,payload):
        return json.loads(payload.decode("utf-8"))

    def parse_message(self,topic, payload):
        t = self.parse_topic(topic)
        if t is None:
            return None

        m = self.parse_payload(payload)
        msg = t.copy()
        msg["value"] = m["v"]
        if all([
                t["level"] != (None, None, None, None),
                t["trange"] != (None, None, None),
        ]):
            if "d" in m:
                msg["datetime"] = datetime.strptime(m["d"], "%Y-%m-%dT%H:%M:%S")
            else:
                msg["datetime"] = datetime.now()
        else:
            msg["datetime"] = None
    
        if "a" in m:
            msg["attributes"] = m["a"]
        else:
            msg["attributes"] = {}
            
        return msg

    def on_log(self,client, userdata, level, buf):
        if userdata["logging"]:
            userdata["logging"].debug(buf)

    def on_connect(self,client, userdata, flags, rc):
        for topic in userdata["topics"]:
            client.subscribe(topic)

    def on_message(self,client, userdata, message):

        if userdata["exchange"]:
            exchange=userdata["exchange"]
        else:
            exchange="exchange"
        routing_key=exchange

        if userdata["logging"]:
            logging=userdata["logging"]

        channel=userdata["channel"]

        logging.info('Message: topic '+str(message.topic) +" payload "+str(message.payload))
        
        try:
            m = self.parse_message(message.topic, message.payload)
            if m is None:
                    return
            msg = dballe.Message("generic")
            if m["ident"] is not None:
                msg.set_named("ident", dballe.var("B01011", m["ident"]))

            msg.set_named("longitude", dballe.var("B06001", m["lon"]))
            msg.set_named("latitude", dballe.var("B05001", m["lat"]))
            msg.set_named("rep_memo", dballe.var("B01194", m["rep_memo"]))

            if m["datetime"] is not None:
                msg.set_named("year", dballe.var("B04001", m["datetime"].year))
                msg.set_named("month", dballe.var("B04002", m["datetime"].month))
                msg.set_named("day", dballe.var("B04003", m["datetime"].day))
                msg.set_named("hour", dballe.var("B04004", m["datetime"].hour))
                msg.set_named("minute", dballe.var("B04005", m["datetime"].minute))
                msg.set_named("second", dballe.var("B04006", m["datetime"].second))

            var = dballe.var(m["var"], m["value"])

            for b, v in m["attributes"].items():
                var.seta(dballe.var(b, v))

            msg.set(m["level"], m["trange"], var)

            exporter = dballe.Exporter(encoding="BUFR")
            totalbody=exporter.to_binary(msg)
            #sys.stdout.buffer.write(exporter.to_binary(msg))
            #sys.stdout.flush()
            
            #channel.queue_declare(queue=queue)
            properties=pika.BasicProperties(
                user_id= user,
                delivery_mode = 2, # persistent
            )
            try:
                channel.basic_publish(exchange=exchange,
                                      routing_key=routing_key,
                                      body=totalbody,
                                      properties=properties)
                logging.debug('Message publish was confirmed')
                logging.info(" [x] message Sent")
            except pika.exceptions.UnroutableError:
                logging.error('Message could not be confirmed')
            

        except Exception:
            import traceback
            traceback.print_exc()


#add option for topic and dsn
class  mydaemon(daemon.Daemon):

    def optionparser(self):
        op = super(mydaemon, self).optionparser()
        op.add_option("-d", "--datalevel",dest="datalevel", help="sample or report: define the istance to run: select topic, dns,logfile, errorfile and lockfile (default %default)", default="sample")
        op.add_option("-s", "--stationtype",dest="stationtype", help="fixed or mobile: define the istance to run: select topic, dns,logfile, errorfile and lockfile (default %default)", default="fixed")
        #op.add_option("-t", "--topic",dest="topic", help="topic root to subscribe on mqtt broker (default %default)", default="rmap")
        #op.add_option("-d", "--dsn",dest="dsn", help="topic root to subscribe on mqtt broker (default %default)", default=rmap.settings.dsnrmap)
        return op 	  				 

mqtt2amqpd = mydaemon(
        stdin="/dev/null",
        stdout=rmap.settings.logfilemqtt2amqpd,
        stderr=rmap.settings.errfilemqtt2amqpd,
        pidfile=rmap.settings.lockfilemqtt2amqpd,
        user=rmap.settings.usermqtt2amqpd,
        group=rmap.settings.groupmqtt2amqpd
)

# catch signal to terminate the process
class GracefulKiller:
    kill_now = False
    def __init__(self):
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)

    def exit_gracefully(self,signum, frame):
        self.kill_now = True


def main(self):

    import os,sys,time
    import logging.handlers
    import subprocess
    import traceback

    #arm the signal handler
    killer = GracefulKiller()

    # configure the logger
    formatter=logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s",datefmt="%Y-%m-%d %H:%M:%S")
    handler = logging.handlers.RotatingFileHandler(self.options.stdout, maxBytes=5000000, backupCount=10)
    handler.setFormatter(formatter)
    
    # Add the log message handler to the root logger
    logging.getLogger().addHandler(handler)
    logging.getLogger().setLevel(logging.DEBUG)

    logging.info('Starting up mqtt2amqpd')

    dsndict={"sample":{},"report":{}}
    dsndict["sample"]["fixed"]=rmap.settings.dsnsample_fixed
    dsndict["sample"]["mobile"]=rmap.settings.dsnsample_mobile
    dsndict["report"]["fixed"]=rmap.settings.dsnreport_fixed
    dsndict["report"]["mobile"]=rmap.settings.dsnreport_mobile

    
    if not (self.options.datalevel in list(dsndict.keys())):
        logging.error('Invalid dsn')
        sys.stdout.write("Invalid dsn\n")
        return False

    if not (self.options.stationtype in list(dsndict[self.options.datalevel].keys())):
        logging.error('Invalid dsn')
        sys.stdout.write("Invalid dsn\n")
        return False

    topicdict={"sample":{},"report":{}}
    topicdict["sample"]["fixed"]  = "{}/+/+/{}/#".format(rmap.settings.topicsample,"fixed")
    topicdict["sample"]["mobile"] = "{}/+/+/{}/#".format(rmap.settings.topicsample,"mobile")
    topicdict["report"]["fixed"]  = "{}/+/+/{}/#".format(rmap.settings.topicreport,"fixed")
    topicdict["report"]["mobile"] = "{}/+/+/{}/#".format(rmap.settings.topicreport,"mobile")


    if not (self.options.datalevel in list(topicdict.keys())):
        logging.error('Invalid topic')
        sys.stdout.write("Invalid topic\n")
        return False

    if not (self.options.stationtype in list(topicdict[self.options.datalevel].keys())):
        logging.error('Invalid topic')
        sys.stdout.write("Invalid topic\n")
        return False

    dsn   = dsndict[self.options.datalevel][self.options.stationtype]
    logging.info('DSN: %s'% dsn)
    topic = topicdict[self.options.datalevel][self.options.stationtype]
    logging.info('Topic: %s'% topic)
    
    exchange=self.options.datalevel+"_"+self.options.stationtype


    credentials=pika.PlainCredentials(user, password)
    
    # connection_attempts (int) - Maximum number of retry attempts
    # retry_delay (int|float) - Time to wait in seconds, before the next
    # socket_timeout (int|float) - Use for high latency networks
    
    
    connection = pika.BlockingConnection(pika.ConnectionParameters(
        host=host,credentials=credentials,
        connection_attempts=3,
        retry_delay=5,
        socket_timeout=3.,
        heartbeat=0))

    channel = connection.channel()    
    
    # Turn on delivery confirmations
    channel.confirm_delivery()

    # If you want to use a specific client id, use
    # mqttc = MyMQTTClass("client-id")
    # but note that the client id must be unique on the broker. Leaving the client
    # id parameter empty will generate a random id for you.

    mqttclient = MyMQTTClass(userdata={
        "topics": [topic],
        "logging": logging,
        "exchange":exchange,
        "channel":channel
    })

    mqttclient.connect(host=host)


    # infinite loop
    while True:
        try:
            mqttclient.loop()
        except Exception as exception:
            logging.error('Exception occured: ' + str(exception))
            logging.error(traceback.format_exc())
            logging.error('Subprocess failed')
            time.sleep(10)
        # terminate on keyboard interrupt
        except KeyboardInterrupt:
            sys.stdout.write("keyboard interrupt\n")
            logging.info("keyboard interrupt\n")
            return False
        # terminate without error
        #else:
            # no exception was raised
            #logging.info('work finished')
        finally:
            
            # check if we have to terminate together with other exceptions
            if killer.kill_now:

                mqttclient.disconnect()
                logging.debug("MQTT connection closed")
                connection.close()
                logging.debug("AMQP connection closed")

                logging.info("killed by signal\n")
                logging.info('Subprocess finished')
                return False
    
#            p1 = subprocess.Popen(["mqtt2bufr","-t",topic],cwd=self.cwd, stdout=subprocess.PIPE,stderr=subprocess.PIPE)
#	    p2 = subprocess.Popen(["arki-query", "--stdin=bufr","--inline",""],cwd=self.cwd, stdin=p1.stdout, stdout=subprocess.PIPE,stderr=subprocess.PIPE)
#	    p3 = subprocess.Popen(["arki-xargs", "-n","1", "toamqp", exchange],cwd=self.cwd, stdin=p2.stdout, stdout=subprocess.PIPE,stderr=subprocess.PIPE)

            

if __name__ == '__main__':

    import sys, os
    
    mqtt2amqpd.cwd=os.getcwd()

    if mqtt2amqpd.service():

        sys.stdout.write("Daemon started with pid %d\n" % os.getpid())

        main(mqtt2amqpd)  # (this code was run as script)
            
        for proc in mqtt2amqpd.procs:
            proc.wait()

        sys.stdout.write("Daemon stoppped\n")
        sys.exit(0)
